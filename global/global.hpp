#pragma once

/*
此静态库的导出头文件
包含此头文件，就能使用此库的所有功能。

此库的头文件不使用宏定义，而是使用 #pragma once 的方式防止重复包含。
这是因为，虽然#pragma once 不是c++标准硬性规定的，但它受主流编译器支持较好。
而使用宏定义虽然是标准做法，但是万一和其他人编写的其他库产生冲突，很可能导致严重问题。
例如，此库实现了高精度整数，以及依赖于高精度整数运算的RSA加密算法，而很多常用的库也都实现了自己的一套高精度和加密算法，
万一其中有名字冲突，麻烦无穷无尽。
宏定义导致的问题除了无法通过编译，还有可能是通过编译但引入未定义行为，这比不通过编译更加可怕。
不要使用不支持#pragma once 的编译器编译此库。

对任何有源代码的库，都最好自己编译成静态库，并在链接时打开“在链接时生成代码”的优化选项。
这允许链接器在链接库时，根据库的源代码做进一步优化。
由于有完整的源代码，链接器可以在链接时对函数进行展开和内联，去掉逻辑中重复或无效的部分。
例如，假设类 T 重载了 [] 运算符，该重载会在运行期检测访问越界。
有了完整源代码，链接器在链接期就可以判断出，某些地方本来就不会越界，不会触发越界访问的判断语句，从而优化代码。
这样一来，实现代码时就比较轻松了，可以不用手写 带运行期检查的安全版本 和 不带运行期检查的不安全版本 ，
而是只写带检查的安全版本，将编译期能进行的检查和优化的地方交给编译器。
而编译期不能检查的也会在运行期检查到，安全和优化两手都抓。

既然使用c++，我希望不要有莫名其妙的限制，尤其是很多程序员痛恨的异常和重载。
看看c标准库，没有重载导致语义相同的函数不得不写很多个，比如字符串和算术类型的转换，不得不对 long 、int、long long等分别都用不同的函数名，为了缩短函数名，又要用极简的缩写命名。
就我的体验而言，这样的函数我用起来并不舒适。

异常更是被很多人视为洪水猛兽，他们认为只应该用错误码。
他们可能没搞清异常的用途。
c++标准库中的异常，要么是来自外部的、不可控的严重错误（内存分配失败），
要么是检测到未定义行为（std::any检测到错误的类型转换、std::vector的at函数检测到下标访问越界），
要么是传递系统底层的错误(std::system_error)。
而像因权限不足无法访问文件，std::cin和std::cout发生的可恢复性的输入输出错误，标准库是用错误码的形式。
所以，异常是用来报告严重错误的，这些错误要么是不可控的，要么就是写出了在语言层面就绝对不应该写出来的代码（如下标越界、死锁），
不论哪种，都是不可恢复的错误。
异常是用来报告“不可恢复的错误”的！异常不是用来报告用户输入不合法、http连接失败这类业务逻辑错误的。
发生异常的时候，程序就应该崩溃。之所以抛出异常，只是为了让程序记录崩溃日志或者执行一些清理代码，
不是为了让程序强行处理它不该处理的错误，并继续带病运行下去的！
对于这样的错误，就是应该使用异常，而不是任何其他机制。
对于可恢复性的业务逻辑错误，再去考虑用错误码或其他机制。
*/

//#include ".\stl.hpp"

#include ".\blank.hpp"
#include ".\base.hpp"
#include ".\string.hpp"
#include ".\tree.hpp"
#include ".\lock.hpp"
#include ".\fundamental.hpp"
#include ".\timer.hpp"
#include ".\cipher.hpp"
#include ".\message.hpp"
#include ".\storage.hpp"
#include ".\matcher.hpp"
#include ".\log.hpp"